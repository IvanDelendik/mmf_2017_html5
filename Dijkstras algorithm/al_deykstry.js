{
    let i; //переменная для итерирования (она используется чересчур часто, чтобы каждый раз её объявлять в for)
    let edges; //таблица весов рёбер
    let numOfNodes; //число узлов
    let firstNode; //начальный узел пути
    let lastNode; //конечный узел пути

    /*функция для считывания числа узлов, проверки на корректность и создания таблицы весов (ещё не заполненной)*/
    function Create() {
        numOfNodes = Number(document.Graph1.NumberOfNodes.value);
        if (!Number.isInteger(numOfNodes) || numOfNodes < 1 || numOfNodes > 1000) {
            alert("Некорректный ввод\n"
                + "Количество узлов - натуральное число,\n"
                +"не превышающее 1000");
            numOfNodes = undefined;
        } else {
            edges = new Array(numOfNodes);
            for (i = 0; i < numOfNodes; i++) {
                edges[i] = new Array(i);
            }
            console.clear();
        }
    }

    /*функция для заполнения одной ячейки таблицы весов (с проверкой на корректность введённых значений)*/
    function Assign() {
        if (numOfNodes === undefined) { alert("Введите количество узлов"); } //сначала должно быть введено число узлов
        else {
            let node1;
            let node2;
            let mass;
            node1 = Number(document.Graph1.Node1.value);
            node2 = Number(document.Graph1.Node2.value);
            mass = Number(document.Graph1.Mass.value);
            if (!Number.isInteger(node1) || node1 < 1 || node1 > numOfNodes
            || !Number.isInteger(node2) || node2 < 1 || node2 > numOfNodes
            || isNaN(mass) || mass <= - Number.EPSILON || node1 === node2) {
                alert("Некорректный ввод\n"
                    + "Номера соединяемых узлов -\n"
                    + "различные натуральные числа\n"
                    + "в пределах указанного количества\n"
                    + "Вес ребра - неотрицательное число\n");
            } else {
                console.log(node1 + " --- " + mass + " --- " + node2);
                if (node1 < node2) {
                    edges[node2-1][node1-1] = mass;
                } else {
                    edges[node1-1][node2-1] = mass;
                }
            }
        }
    }

    /*функция для считывания начального и конечного узлов пути с проверкой на корректность*/
    function FirstLast() {
        if (numOfNodes === undefined) { alert("Введите количество узлов"); } //сначала должно быть введено число узлов
        else {
            firstNode = Number(document.Graph1.From.value)-1;
            lastNode = Number(document.Graph1.To.value)-1;
            if (!Number.isInteger(firstNode) || firstNode < 0 || firstNode >= numOfNodes
            || !Number.isInteger(lastNode) || lastNode < 0 || lastNode >= numOfNodes
            || firstNode === lastNode) {
                alert("Некорректный ввод\n"
                    + "Номера начального и конечного узлов -\n"
                    + "это различные натуральные числа\n"
                    + "в пределах указанного количества\n");
                firstNode = undefined;
                lastNode = undefined;
            }
        }
    }

    /*фуснкция для реализации алгоритма Дейкстры*/
    function AlgorithmD() {
        /*в алгоритме номера узлов уменьшены на 1*/
        if (numOfNodes === undefined) {
            alert("Введите количество узлов"); 
        } else if (firstNode === undefined || lastNode === undefined){
            alert("Введите номера начального и конечного узла"); //сначала должны быть введены число узлов и номера начального и конечного узлов
        } else {
            let nodes = new Array(numOfNodes); //создание массива узлов
            for (i = 0; i < numOfNodes; i++) {
                nodes[i] = { prevNode: [], wayMass: undefined };
            } /*его первоначальное заполнение: 
            свойство prevNode - массив предыдущих узлов для кратчайшего пути на данном этапе; свойство wayMass - длина (вес) кратчайшего пути на данном этапе.
            функция fill при заполнении объектами (в том числе массивами) неудобна: если потом изменить один элемент, изменятся все*/
            let usedNodes = 0; //счётчик исследованных узлов для определения связности графа
            let nodeInQuest = firstNode; //исследуемый узел
            /*исследуемый узел здесь - узел, кратчайший путь до которого уже известен, 
            причём он является также кратчайшим среди путей до всех рассмотренных на данном этапе узлов;
            а сейчас ищутся все связанные с ним и ещё не исследованные узлы.
            рассматриваемый узел - узел, связанный (или проверяемый на связанность) с исследуемым,
            у которого, исходя из веса связывающего ребра, могут быть изменены свойства prevNode и wayMass*/
            nodes[firstNode].wayMass = 0; //для первого узла путь нулевой
            let min; //будет использоваться для поиска следующего узла для исследования
            let wayInQuest; //альтернативная длина пути до некоторого узла, которая будет сравниваться с его свойством wayMass
            /*вспомогательная функция, чтобы не повторять одинаковый кусок кода.
            ещё одна причина определить переменную i заранее*/
            function Simplify() {
                if (Math.abs(wayInQuest - nodes[i].wayMass) < Number.EPSILON) {
                    nodes[i].prevNode.push(nodeInQuest); /*если альтернативный путь имеет такую же длину, что и кратчайший на данном этапе путь до рассмотриваемого узла,
                    то добавляем ещё один узел в качестве предыдущего*/
                } else if (!(nodes[i].wayMass - wayInQuest < Number.EPSILON)) {
                    /*если же альтернативный путь короче или свойство wayMass рассматриваемого узла ещё не определено,
                    то для этого узла данный путь станет свойством wayMass, а исследуемый узел - пока единственным предыдущим*/
                    nodes[i].prevNode = [nodeInQuest];
                    nodes[i].wayMass = wayInQuest;
                }
            }
            do {
                /*таблица весов имеет треугольный вид (над главной диагональю), поэтому вес ребра, соединяющего исследуемый узел с рассматриваемым,
                ищется в ней по разному в зависимости от того, как соотносятся их номера*/
                for (i = 0; i < nodeInQuest; i++) { //номер рассматриваемого узла меньше, чем исследуемого
                    if (edges[nodeInQuest][i] !== undefined) { //только если рассматриваемый узел связан с исследуемым
                        wayInQuest = nodes[nodeInQuest].wayMass + edges[nodeInQuest][i]; //определение альтернативного пути
                        Simplify(); //исследование альтернативного пути с возможным изменением свойств рассматриваемого узла
                        edges[nodeInQuest][i] = undefined; //удаление рассмотренного ребра, чтобы исследуемый узел не стал потом рассматриваемым
                    }
                }
                /*исследуемый узел не может совпадать с рассматриваемым*/
                for (i = nodeInQuest + 1; i < numOfNodes; i++) { //номер рассматриваемого узла больше, чем исследуемого
                    if (edges[i][nodeInQuest] !== undefined) { //только если рассматриваемый узел связан с исследуемым
                        wayInQuest = nodes[nodeInQuest].wayMass + edges[i][nodeInQuest]; //определение альтернативного пути
                        Simplify(); //исследование альтернативного пути с возможным изменением свойств рассматриваемого узла
                        edges[i][nodeInQuest] = undefined; //удаление рассмотренного ребра, чтобы исследуемый узел не стал потом рассматриваемым
                    }
                }
                nodes[nodeInQuest].wayMass = undefined; //удаление свойства кратчайшего пути для уже исследованного, чтобы он не стал снова исследуемым 
                usedNodes++; //увеличение числа исследованных узлов
                min = Infinity; //если он так и останется бесконечностью, цикл завершится
                /*среди всех узлов, для которых определён кратчайший на данном этапе путь, кроме конечного,
                определим узел с наикратчайшим путём, он станет следующим исследуемым*/
                for (i  = 0; i < numOfNodes; i++) {
                    if(nodes[i].wayMass < min && i!=lastNode){
                        nodeInQuest = i;
                        min = nodes[i].wayMass;
                    }
                }
            } while (isFinite(min)); //пока есть необследованные узлы, до которых можно "добраться" из начального, кроме конечного
            let answer = "";
            if (nodes[lastNode].wayMass === undefined) { //если до конечного узла так и не "добрались"
                answer = "Граф несвязный\n" + "Не сущесвует пути\n" + "между заданными узлами";
            } else {
                if (usedNodes < numOfNodes - 1) { //если существует путь от начального до конечного узла, но часть узлов не было исследовано
                    answer = "Граф несвязный\n";
                }
                let ways = [[lastNode]]; //начальное определение массива из массивов номеров узлов, составляющих кратчайшие пути от начального узла до конечного
                for (i = 0; i < ways.length; i++) { //в процессе прохождения цикла ways.length может расти, но не до бесконечности
                    //i - номер рассматриваемого массива
                    while (ways[i][0] != firstNode) { //пока первым элементом рассматриваемого массива не станет номер начального узла
                        /*если у первого узла рассматриваемого массива больше одного предыдущего узла (свойство prevNode),
                        добавляем в конец ways массивы с добавленными в начало номерами этих предыдущих узлов, кроме первого из них
                        (в каждом добавленном массиве добавляем только один предыдущий узел и везде разный)*/
                        for (let j = 1; j < nodes[ways[i][0]].prevNode.length; j++) {                             
                            ways.push([nodes[ways[i][0]].prevNode[j]].concat(ways[i])); 
                        }
                        ways[i].unshift(nodes[ways[i][0]].prevNode[0]); //в рассматриваемый массив в начало добавляем первый из предыдущих узлов
                    }
                }
                ways = ways.map(x => x.map(y => y+1)); //увеличиваем номера всех узлов на единицу, ведь мы рассматривали их на единицу меньшими
                answer = answer + ways.join("\n");
            }
            console.log("\n--- solution --- solution ---\n\n"+answer);
            alert(answer);
        }
    }
}